https://leetcode.com/tag/tree/
https://leetcode.com/tag/dynamic-programming/

https://leetcode.com/problems/maximum-subarray/
#define _merge_P_from_left(nums, idxL, idxR, P) for (P = 0; idxL <= idxR && nums[idxL] >= 0; idxL++) {P += nums[idxL];}
#define _merge_N_from_left(nums, idxL, idxR, N) for (N = 0; idxL <= idxR && nums[idxL] <= 0; idxL++) {N += nums[idxL];}

void findMax(int* nums, int* idxL, int* idxR, int *myContP, int* myDiscontPMax)
{
    int N, P;
    int nextDiscontPMax;
    
    do
    {   /* Merge PNP from left */
        _merge_N_from_left(nums, (*idxL), (*idxR), N)
        _merge_P_from_left(nums, (*idxL), (*idxR), (*myDiscontPMax))
            
        if ((*myContP + N) > 0 && (N + *myDiscontPMax) > 0)
        {
            *myContP += (N + *myDiscontPMax);
            *myDiscontPMax = 0;
        }
        else
            break;
    } while ((*idxL) <= (*idxR));
    
    if ((*idxL) <= (*idxR))
    {
        findMax(nums, idxL, idxR, myDiscontPMax, &nextDiscontPMax);
        if ((*myContP + N) > 0 && (N + *myDiscontPMax) > 0)
        {
            *myContP += (N + *myDiscontPMax);
            *myDiscontPMax = nextDiscontPMax;
        }
        else if (*myDiscontPMax < nextDiscontPMax)
            *myDiscontPMax = nextDiscontPMax;
    }

    return;
}

int maxSubArray(int* nums, int numsSize)
{
    int idxL = 0;
    int idxR = numsSize-1;
    int maxN;
    int myContP, myDiscontPMax;

    /*********************************************************************
     * Get ride of continuously N at left most and right most
     *********************************************************************/
    
    /* Get ride of Left N */
    if (nums[idxL] <= 0)
        for (maxN = nums[idxL++]; idxL <= idxR && nums[idxL] <= 0; idxL++)
            if (maxN < nums[idxL])
                maxN = nums[idxL];
 
    if (idxL > idxR)   //---------------- Answer of all N/0 string
        return maxN;

    _merge_P_from_left(nums, idxL, idxR, myContP)
    if (idxL > idxR)
        return myContP;
        
    findMax(nums, &idxL, &idxR, &myContP, &myDiscontPMax);
    
    return (myContP > myDiscontPMax) ? myContP : myDiscontPMax;
}
